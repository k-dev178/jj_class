# 2025-2 알고리즘 1주차(2차시) 요약 😺

---

## 0) 오늘 수업 한 줄 요약 (TL;DR)
- **알고리즘 = 문제를 푸는 ‘정확한 단계들’** → 먼저 **의사코드**로 생각 정리 → 그다음 **코드**로 옮기기! ⛓️  
- **효율(시간/메모리)**이 좋을수록 실전에서 **빠르고 가볍게** 돈다.  
- 예제로 **순차 탐색**과 **행렬 곱셈**의 의사코드를 맛봄.  

---

## 1) 공지 & 운영 (교수님 멘트 요약)
- **출석 자동체크** 안 찍히면 **수업 끝나기 전** 꼭 말하기. 나중에 “그때 왔어요…”는 반영 어려움.
- 1학년도 들을 수 있음. 다만 **개념을 차근차근** 따라오는 게 중요!
- 과제/연습 포인트: **숫자만 따라가지 말고**, 머릿속에 **“어떻게 굴러가는지” 그림**을 그릴 것.

---

## 2) 알고리즘이 뭐길래? 🤔
- **정의**: “문제를 해결하기 위한 **명확하고 단계적인 절차/방법**”  
- **이 강의에서 다룰 것**:  
  - 문제 푸는 **방법론**: Divide & Conquer / Dynamic Programming / Greedy  
  - **문제 유형**: Sorting / Searching 등 대표 문제로 훈련  
- **효율 분석 관점**:  
  - **시간**(얼마나 오래 걸리나) + **공간**(메모리를 얼마나 쓰나)  
- **문제는 ‘핵심 모듈’ 중심으로**: 전체 서비스 말고, **핵심 로직**(정렬·탐색 같은 엔진)에 집중!

---

## 3) 용어 미니사전 🧸
- **파라미터**: 문제에서 아직 값이 정해지지 않은 변수(예: `S`, `n`, `x`)  
- **문제 패턴(class)** / **개별 문제(instance)** / **입력사례(instance)** / **해답(solution)**: 파라미터에 값을 채워가며 **문제→입력→해답**을 연결하는 개념들  

---

## 4) 의사코드(Pseudocode)로 생각 정리 ✍️
- 자연어 설명은 길고 모호해지기 쉬움 → **의사코드**로 **“바로 코드로 옮길 수 있을 정도”**만 명확히!  
- 인덱스는 슬라이드 스타일대로 **1부터 시작**해도 됨(실제 코딩할 땐 맞춰서 바꾸면 됨).  
- 비교식 `0 < x < 10` 같은 **수학식 표기**도 OK(읽기 쉬우면 장땡).  
- 스왑은 `exchange S[j] and S[i]`처럼 **직관 표기** 허용.  

---

## 5) 예제 1 — **순차 탐색(Sequential Search)** 🔎
> **문제**: 배열 `S[1..n]`에서 값 `x`가 있는지 위치를 찾아라(없으면 `0`).  
> **아이디어**: **맨 앞부터 차례대로** 비교!

**의사코드(슬라이드 Algo 1.1 형태)**:  
```text
location ← 1
while (location ≤ n AND S[location] ≠ x):
    location ← location + 1
if (location > n): location ← 0
```

**머릿속 그림(직관 만들기)**  
- `x=5`, `S=[9,3,2,5,...]`라면 → 9 ❌ → 3 ❌ → 2 ❌ → **5 ⭕** (여기서 멈추고 위치 반환!)  
- 포인트: **“무엇을 비교하고 건너뛰는지”**를 상상하면서 따라가기.

---

## 6) (슬라이드만) **교환 정렬(Exchange Sort)** 🧩
> 슬라이드에는 있음(**Algo 1.3**), **오늘 수업에선 미진행**.  
- 비내림차순으로 정렬하는 간단한 2중 루프 정렬(작은 값을 앞으로 바꿔치기)

---

## 7) 예제 2 — **행렬 곱셈(Matrix Multiplication)** 🧮
> **문제**: `A(l×m)`와 `B(m×n)`의 곱 `C(l×n)` 구하기.  
> **아이디어**: `C[i][j] = Σ(k=1..m) A[i][k] * B[k][j]`

**의사코드(슬라이드 Algo 1.4)**:  
```text
for i = 1..l:
  for j = 1..n:
    C[i][j] ← 0
    for k = 1..m:
      C[i][j] ← C[i][j] + A[i][k] * B[k][j]
```

**머릿속 그림**  
- `k=1→m`로 이동하며 **짝지어 곱하고** `C[i][j]`에 **누적**!  
- 표/화살표 그려 보면 금방 이해됨.

---

## 8) 왜 효율이 중요해? ⚡
- **시간/공간** 효율이 좋아야 **모바일/임베디드** 같은 **제한 많은 환경**에서도 잘 돈다.  
- 이 강의는 앞으로 **시간·공간 관점**으로 성능을 보고 비교하는 연습을 계속함.

---

## 9) 바로 해보는 미니 과제 ✅
- [ ] **순차 탐색**을 의사코드→파이썬/자바/C 중 하나로 구현  
  - `S=[9,3,2,5,7]`, `x=5/8`로 **두 케이스** 테스트  
- [ ] **행렬 곱셈**을 2×3 · 3×2 예제로 손계산 + 코드 구현  
  - `k`가 바뀔 때 **무엇을 곱하고 더하는지** 주석으로 설명  
- [ ] **설명 연습**: 친구에게 “왜 이렇게 돌아가는지” **그림**으로 설명해 보기

---

## 10) 다음 시간 예고 🔭
- 본격적으로 **방법론(분할정복·DP·그리디)**에 들어가며,  
  같은 문제를 **여러 방식**으로 풀어 보고 **효율 비교**까지!
